# 希尔排序

1959 年一个叫 `Donald L. Shell (March 1, 1924 – November 2, 2015)` 的美国人在 `Communications of the ACM 国际计算机学会月刊` 发表了一篇文章，从此名为希尔排序的算法诞生了。

注： `ACM = Association for Computing Machinery`，国际计算机学会，世界性的计算机从业员专业组织，创立于1947年，是世界上第一个科学性及教育性计算机学会。

`希尔排序`是`直接插入排序`的改进版本。因为直接插入排序对那些几乎已经排好序的数列来说，排序效率极高，达到了 `O(n)` 的线性复杂度，但是每次只能将数据移动一位。希尔排序创造性的可以将数据移动 `n` 位，然后将 `n` 一直缩小，缩到与直接插入排序一样为 `1`，请看下列分析。

希尔排序属于插入类排序算法。

## 一、算法介绍

有一个 `N` 个数的数列：

1. 先取一个小于 `N` 的整数 `d1`，将位置是 `d1` 整数倍的数们分成一组，对这些数进行直接插入排序。
2. 接着取一个小于 `d1` 的整数 `d2`，将位置是 `d2` 整数倍的数们分成一组，对这些数进行直接插入排序。
3. 接着取一个小于 `d2` 的整数 `d3`，将位置是 `d3` 整数倍的数们分成一组，对这些数进行直接插入排序。
4. ...
5. 直到取到的整数 `d=1`，接着使用直接插入排序。

这是一种分组插入方法，最后一次迭代就相当于是直接插入排序，其他迭代相当于每次移动 `n` 个距离的直接插入排序，这些整数是两个数之间的距离，我们称它们为增量。

我们取数列长度的一半为增量，以后每次减半，直到增量为1。

举个简单例子，希尔排序一个 12 个元素的数列：`[5 9 1 6 8 14 6 49 25 4 6 3]`，增量 `d` 的取值依次为：`6，3，1`：

```go
x 表示不需要排序的数


取 d = 6 对 [5 x x x x x 6 x x x x x] 进行直接插入排序，没有变化。
取 d = 3 对 [5 x x 6 x x 6 x x 4 x x] 进行直接插入排序，排完序后：[4 x x 5 x x 6 x x 6 x x]。
取 d = 1 对 [4 9 1 5 8 14 6 49 25 6 6 3] 进行直接插入排序，因为 d=1 完全就是直接插入排序了。
```

越有序的数列，直接插入排序的效率越高，希尔排序通过分组使用直接插入排序，因为步长比 `1` 大，在一开始可以很快将无序的数列变得不那么无序，比较和交换的次数也减少，直到最后使用步长为 `1` 的直接插入排序，数列已经是相对有序了，所以时间复杂度会稍好一点。

在最好情况下，也就是数列是有序时，希尔排序需要进行 `logn` 次增量的直接插入排序，因为每次直接插入排序最佳时间复杂度都为：`O(n)`，因此希尔排序的最佳时间复杂度为：`O(nlogn)`。

在最坏情况下，每一次迭代都是最坏的，假设增量序列为： `d8 d7 d6 ... d3 d2 1`，那么每一轮直接插入排序的元素数量为：`n/d8 n/d7 n/d6 .... n/d3 n/d2 n`，那么时间复杂度按照直接插入的最坏复杂度来计算为：

```go
假设增量序列为 ⌊N/2⌋ ，每次增量取值为比上一次的一半小的最大整数。

O( (n/d8)^2 + (n/d7)^2 + (n/d6)^2 + ... + (n/d2)^2 + n^2)

= O(1/d8^2 + 1/d7^2 + 1/d6^2 + ... + 1/d2^2 + 1) * O(n^2)
= O(等比为1/2的数列和) * O(n^2)
= O(等比求和公式) * O(n^2)
= O( (1-(1/2)^n)/(1-1/2) ) * O(n^2)
= O( (1-(1/2)^n)*2 ) * O(n^2)
= O( 2-2*(1/2)^n ) * O(n^2)
= O( < 2 ) * O(n^2)
```

所以，希尔排序最坏时间复杂度为 `O(n^2)`。

不同的分组增量序列，有不同的时间复杂度，但是没有人能够证明哪个序列是最好的。`Hibbard` 增量序列：`1，3，7，···，2n−1` 是被证明可广泛应用的分组序列，时间复杂度为：`Θ(n^1.5)`。

希尔排序的时间复杂度大约在这个范围：`O(n^1.3)~O(n^2)`，具体还无法用数学来严格证明它。

希尔排序不是稳定的，因为每一轮分组，都使用了直接插入排序，但分组会跨越 `n` 个位置，导致两个相同的数，发现不了对方而产生了顺序变化。

## 二、算法实现

我们先看一下直接插入排序的实现（具体介绍请看 《插入排序》章节）：

```
func InsertSort(list []int) {
    n := len(list)
    // 进行 N-1 轮迭代
    for i := 1; i <= n-1; i++ {
        deal := list[i] // 待排序的数
        j := i - 1      // 待排序的数左边的第一个数的位置

        // 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理
        if deal < list[j] {
            // 一直往左边找，比待排序大的数都往后挪，腾空位给待排序插入
            for ; j >= 0 && deal < list[j]; j-- {
                list[j+1] = list[j] // 某数后移，给待排序留空位
            }
            list[j+1] = deal // 结束了，待排序的数插入空位
        }
    }
}
```

然后我们再来实现希尔排序：

```
// ShellSort 增量序列折半的希尔排序
func ShellSort(list []int) {
	// 数组长度
	n := len(list)

	// 每次减半，直到步长为 1
	for step := n / 2; step >= 1; step /= 2 {
		// 开始插入排序，每一轮的步长为 step
		// 直接插入排序算法请看 《插入排序》章节

		// 插入排序开始
		for i := step; i <= n-1; i += step {
			deal := list[i] // 待排序的数
			j := i - step   // 待排序的数左边的最近一个数的位置

			// 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理
			if deal < list[j] {
				// 一直往左边找，比待排序大的数都往后挪，腾空位给待排序插入
				for ; j >= 0 && deal < list[j]; j -= step {
					list[j+1] = list[j] // 某数后移，给待排序留空位
				}
				list[j+step] = deal // 结束了，待排序的数插入空位
			}
		}
		// 插入排序结束

	}
}

func main() {
	list := []int{5}
	ShellSort(list)
	fmt.Println(list)

	list1 := []int{5, 9}
	ShellSort(list1)
	fmt.Println(list1)

	list2 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
	ShellSort(list2)
	fmt.Println(list2)

	list3 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3, 2, 4, 23, 467, 85, 23, 567, 335, 677, 33, 56, 2, 5, 33, 6, 8, 3}
	ShellSort(list3)
	fmt.Println(list3)
}
```

输出：

```go
[5]
[5 9]
[1 3 4 5 6 6 6 8 9 14 25 49]
[1 2 2 3 3 4 4 5 5 6 6 6 6 8 8 9 14 23 23 25 33 33 49 56 85 335 467 567 677]
```

按照之前分析的几种排序算法，一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，但在大规模还是要使用快速排序，归并排序或堆排序。